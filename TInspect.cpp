// -*- C++ -*- generated by wxGlade 0.4.1 on Fri Aug 18 13:20:07 2006

#include "TInspect.h"

BEGIN_EVENT_TABLE(TInspect, wxDialog)
    EVT_MENU(menu_wt_uniform, TInspect::WSchemeClick)
    EVT_MENU(menu_wt_noise, TInspect::WSchemeClick)
    EVT_MENU(menu_wt_deviation,TInspect::WSchemeClick)
    EVT_MENU(menu_wt_counts, TInspect::WSchemeClick)
    EVT_MENU(menu_recalculate, TInspect::RecalculateClick)
    EVT_MENU(menu_wt_constnoise,TInspect::WSchemeClick)
    EVT_MENU(menu_changee0, TInspect::ChangeE0Click)
	EVT_PAINT(TInspect::DrawPaint)
	EVT_SPIN_UP(file_spin,TInspect::NextFileClick)
	EVT_SPIN_DOWN(file_spin,TInspect::PrevFileClick)
	EVT_SPIN_UP(channel_spin,TInspect::NextChannelClick)
	EVT_SPIN_DOWN(channel_spin,TInspect::PrevChannelClick)
	EVT_SPIN_UP(weight_spin,TInspect::WeightClick)
	EVT_SPIN_DOWN(weight_spin,TInspect::WeightClick)
	EVT_BUTTON(zoom_button,TInspect::UnzoomClick)
	EVT_CHECKBOX(xas_check,TInspect::XASClick)
	EVT_CHECKBOX(use_check,TInspect::UseClick)
   /* EVT_MENU(menu_datacolour, TInspect:DataColorClick)
    EVT_MENU(menu_backcolour, TInspect:BackgroundClick)*/
END_EVENT_TABLE();

TInspect::TInspect(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
    wxDialog(parent, id, title, pos, size, 
	     wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER)
{
    // { wxGlade: TInspect::TInspect
    // zoom_spin_button = new wxSpinButton(this, zoom_spin, wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS);
    // label_1 = new wxStaticText(this, -1, wxT("Zoom"));
    label_2 = new wxStaticText(this, -1, wxT("Weight"), wxDefaultPosition, wxDefaultSize, wxALIGN_RIGHT|wxSP_WRAP);
    weight_spin_button = new wxSpinButton(this, weight_spin, wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS);
    draw_pane = new wxPlotCtrl(this, -1,wxDefaultPosition,wxSize(600,300));
    next_channel_spin = new wxSpinButton(this, channel_spin, wxDefaultPosition, wxDefaultSize, wxSP_HORIZONTAL|wxSP_WRAP);
    next_file_spin = new wxSpinButton(this, file_spin, wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS|wxSP_WRAP);
    checkbox_xas = new wxCheckBox(this, xas_check, wxT("XAS"));
    checkbox_use = new wxCheckBox(this, use_check, wxT("Use"));
    help_button = new wxButton(this, -1, wxT("Help"));
    ok_button = new wxButton(this, wxID_OK, wxT("OK"));
    unzoom_button = new wxButton(this,zoom_button,wxT("Unzoom"));
    popup_menu = new wxMenu;
    Inspect_statusbar = new wxStatusBar(this, -1);

    unzoom = TRUE;     // First time
    set_properties();
    Form_Create();
    do_layout();
    // } wxGlade
}


void TInspect::set_properties()
{
    wxColourDatabase cdb;
    SetTitle(wxT("Inspect"));
    Inspect_statusbar->SetFieldsCount(4);
    int Inspect_statusbar_widths[] = { -1,-1,-1,-1 };
    Inspect_statusbar->SetStatusWidths(4, Inspect_statusbar_widths);
    const wxString Inspect_statusbar_fields[] = {
        wxT("None"), wxT("None"), wxT("k^3"),wxT("None")
    };
    for(int i = 0; i < Inspect_statusbar->GetFieldsCount(); ++i) {
        Inspect_statusbar->SetStatusText(Inspect_statusbar_fields[i], i);
    }
    // set spin button bounds
    weight_spin_button -> SetValue(3);  // i.e. k^3
    weight_spin_button -> SetRange(0,6); // i.e. k^6
    draw_pane -> SetBorderColour(*wxLIGHT_GREY);
    draw_pane -> SetGridColour(*wxLIGHT_GREY);
    draw_pane -> SetAxisLabelColour(*wxBLACK);
    draw_pane -> SetAxisColour(*wxBLACK);
    draw_pane -> SetBackgroundColour(cdb.Find(_("MIDNIGHT BLUE")));
    draw_pane -> SetDrawSymbols(FALSE); //Stacey doesn't like the dots

    lDataColour = wxGenericColour(_("RED"));
    AveDataColour = wxGenericColour(_("YELLOW"));
    line_width = 2;
}


void TInspect::do_layout()
{
    // { wxGlade: TInspect::do_layout
    wxBoxSizer* sizer_4 = new wxBoxSizer(wxVERTICAL);
    wxBoxSizer* sizer_5 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_6 = new wxBoxSizer(wxHORIZONTAL);
    wxBoxSizer* sizer_7 = new wxBoxSizer(wxHORIZONTAL);
    sizer_7->Add(unzoom_button, 0, wxALL|wxADJUST_MINSIZE, 5);
    //sizer_7->Add(label_1, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_7->Add(label_2, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_7->Add(weight_spin_button, 0, wxALL|wxALIGN_RIGHT|wxADJUST_MINSIZE, 5);
    sizer_4->Add(sizer_7, 0, wxEXPAND, 0);
    sizer_4->Add(draw_pane, 1, wxEXPAND, 0);
	sizer_4->SetItemMinSize((wxWindow *)draw_pane,600,300);
    sizer_5->Add(next_channel_spin, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_5->Add(next_file_spin, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_5->Add(checkbox_xas, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_5->Add(checkbox_use, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_6->Add(help_button, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_6->Add(ok_button, 0, wxALL|wxADJUST_MINSIZE, 5);
    sizer_5->Add(sizer_6, 1, wxEXPAND, 0);
    sizer_4->Add(sizer_5, 0, wxEXPAND, 0);
	sizer_4->Add(Inspect_statusbar,0,wxEXPAND,0);
    SetAutoLayout(true);
    SetSizer(sizer_4);
    sizer_4->Fit(this);
    sizer_4->SetSizeHints(this);
    Layout();
    // } wxGlade
	// populate the menus
	wxMenu * wtmenu =  new wxMenu;
	wtmenu->Append(menu_wt_uniform,_("Uniform"));
	wtmenu->Append(menu_wt_deviation,_("Deviation from average"));
	wtmenu->Append(menu_wt_counts,_("Counting statistics"));
	wtmenu->Append(menu_wt_noise,_("Estimated noise"));
	wtmenu->Append(menu_wt_constnoise,_("Noise assumed constant"));
	popup_menu->Append(wxID_ANY,_("Weighting scheme"),wtmenu);
	popup_menu->Append(menu_recalculate,_("Recalculate"));
	popup_menu->Append(menu_changee0,_("Change E0"));
	popup_menu->Append(menu_datacolour,_("Change data colour"));
	popup_menu->Append(menu_backcolour,_("Change background colour"));	
}

void TInspect::Form_Create ()
{
  lWmax   = 1;
  lWCount = 50;   // Keep track of the zoom level
  lOrder  = 3;
  lEmax   = 0;
  lCoData = GData();

  lCoData->Pending= 1;

  ok_button->Enable(TRUE);

  lCal       = NULL;
  lCalPending= 0;

  lWScheme= 1;
  lWscaled= 1;
  lWabs   = 1;

  lcChannel= FALSE;
  loUF     = TRUE;
  lObj = NULL;

  wxCommandEvent dummy_event = wxCommandEvent();
  dummy_event.SetId(menu_wt_uniform);
  WSchemeClick (dummy_event);
}


  // Open 

void TInspect::FormShow ()
{
  TFile *Obj;
  ChangeData (0, 0);

  if (lObj != NULL)
  {
    if (lObj->E0()== 0)

      getE0();

    else

      setlE0(lObj->E0());

    Obj= lObj->First();

    lEmaxlimit= Obj->Emax();

	//Work out maximum energy for all files
	
    while (Obj != NULL)
    {
      if (lEmaxlimit > Obj->Emax())

        lEmaxlimit= Obj->Emax();

      Obj= Obj->Next();
    }

    if ((lEmax== 0) || (lEmax > lEmaxlimit))

      setlEmax(lEmaxlimit);
  }

  Calculate (1);
}


  // Up one channel

void TInspect::NextChannelClick (wxSpinEvent &event)
{
  if (ChangeData (0, 1))

    ReDraw();
}


  // Down one channel

void TInspect::PrevChannelClick (wxSpinEvent &event)
{
  if (ChangeData (0, -1))

    ReDraw();
}


  // Up one file 

void TInspect::NextFileClick (wxSpinEvent &event)
{
  if (ChangeData (1, 0))

    ReDraw();
}


  // Down one file 

void TInspect::PrevFileClick (wxSpinEvent &event)
{
  if (ChangeData (-1, 0))

    ReDraw();
}


  /* Data.  If we are looking at transmission data, we don't
  cycle through transmission channels, and that is implemented
  by returning null from this routine unless the requested channel
  is the same as the one that was set upon invocation */
  // Data 

WData * TInspect::Data (TFile * Obj, int C)
{

  if (Obj != NULL)

    if (Channels (Obj) > 0)

      if (lUF || (C== loChannel))

        return (Obj->Channel (lUF, C));
	  
  return NULL; //No data 
}


  // Number of channels; this will be one larger than the
  // largest available channel

int TInspect::Channels (TFile * Obj)
{
  if (Obj != NULL)
  {
    if (lUF)

      return (Obj->Fluorescence());

    else

      return (Obj->Transmission());
  }
  else

    return (0);
}


  // Move up or down 1 channel
  // In Pascal, the first two arguments are passed by reference,
  // implying that any changes in this routine are passed back to
  // the caller.  We number channels from zero! 
  // If DChannel is zero, we simply wish to load the data from the
  // specified file and channel

WData * TInspect::NextData (TFile ** cObj, int & cChannel, int DChannel)
{
  TFile * oObj;
  int oChannel;
  WData * cData;

    // Change the current channel 

  if (DChannel > 0)

    DChannel= 1;

  if (DChannel < 0)

    DChannel= -1;


    // Search for the next channel in the indicated direction }

  oObj    = *cObj;
  oChannel= cChannel;

  cData= NULL;

  do {

      // Next channel. Channels count from 0.  If we max
	  // out on this file, go to the next one

    cChannel= cChannel + DChannel;

	  // Note that this was > in the Delphi version. But
	  // now the number of channels is one more than the
	  // largest channel number (i.e. we count from zero)
    if (cChannel >= Channels (*cObj))
    {
      *cObj= (*cObj)->Next();

      if (*cObj== NULL)

        *cObj= oObj->First();

      cChannel= 0;
    }

    if (cChannel < 0)
    {
      *cObj= (*cObj)->Prev();

      if (*cObj== NULL)

        *cObj= oObj->Last();

      cChannel= Channels (*cObj)-1;   //Count from zero people
    }

	//  Find the data for this channel
    cData= Data (*cObj, cChannel);

    if (DChannel== 0)

      DChannel= -1;  //search down if this channel unavail.

    else      

      if ((*cObj==  oObj) && (cChannel== oChannel))

        break;   //We have changed nothing
  }

  while (cData == NULL);

  return (cData);
}


    // Move up or down 1 channel or 1 file 

bool TInspect::ChangeData (int DFile, int DChannel)
{

  TFile * oObj    = lObj;
  int oChannel = lChannel;

  WData * cData= NULL;

  if (DFile== 0)

    cData= NextData (&lObj, lChannel, DChannel);

  else
  {
    do {

      NextData (&lObj, lChannel, DFile);
	}

    while ((lObj == oObj) && (lChannel!= oChannel));

    lChannel= oChannel;

    cData= NextData (&lObj, lChannel, 0);
  }

  if (lUF)

    SetTitle(lObj->getName() + wxString::Format (_(" Fluorescence channel %d"), lChannel));

  else

    SetTitle(lObj->getName() + wxString::Format (_(" Transmission channel %d"), lChannel));

  return ((cData != NULL) && ((lObj != oObj) || (lChannel != oChannel)));
}

void TInspect::showWeight()
{
  WData * CData= Data (lObj, lChannel);

  if (CData != NULL)
  {
    Inspect_statusbar->SetStatusText(wxString::Format(_("Scale: %.2f"),CData->Scale),0);
    Inspect_statusbar->SetStatusText(wxString::Format(_("Weight: %.2f"),
                              CData->Weight / CData->Scale / lWscaled),1);
  }
}


bool TInspect::drawXAS (int Mode)
{
  WData * CData;
  double *CD, *WD;   //for curve creation
  double Emin, Emax, D;
  // Change plot bounds for new curves
  if(unzoom) {
	  draw_pane -> SetFitPlotOnNewCurve(TRUE);
	  unzoom = FALSE;
  }
  else draw_pane -> SetFitPlotOnNewCurve(FALSE);

    // Mode 0== RePaint   1== E0 or Emax has changed
    if (draw_pane->GetCurveCount()>0 )
		draw_pane->DeleteCurve(-1);     //remove old curves
    if (Mode== 0)
    {
    /*
        // Draw the scale 

      Xmin= lObj->Emin / 1000;
      Xmax= lObj->Emax / 1000;

      Ymin= 0;
      Ymax= 1;

      Border (0.05, 0.1, 0.0);

      DrawXScale (lObj->Emin / 1000, lObj->Emax / 1000, 0.100, 0.5);

        // Draw the current curve 
*/
      CData = Data (lObj, lChannel);
	  
      if (CData != NULL)
      {
		// unlike the XAFS plot, we maintain ownership of the
		// data, so we pass TRUE for the 'static' argument to wxPlotData
        curve_data = wxPlotData(CData->E->Store(),CData->Data->Store(),
	            CData->E->Nrows(),TRUE);
		curve_data.SetPen(wxPLOTPEN_NORMAL,wxGenericPen(lDataColour,line_width));
        /* GetCurveLimits (CData->E, CData->Data, NULL);

        Xmin= lObj->Emin;
        Xmax= lObj->Emax;

        Border (0.05, 0.1, 0);*/

          // Draw the signal 

        draw_pane->AddCurve(curve_data);
      }

        // Draw the average curve

      /* GetCurveLimits (lCoData->E, lCoData->Data, NULL);

      Xmin= lObj->Emin;
      Xmax= lObj->Emax;

      Border (0.05, 0.1, 0);
      */
        // Draw the signal 

	  curve_data = wxPlotData(lCoData->E->Store(),
	                        lCoData->Data->Store(),
	                        lCoData->E->Nrows(),TRUE);
	  curve_data.SetPen(wxPLOTPEN_NORMAL,wxGenericPen(AveDataColour,line_width));
      curve_data.SetPen(wxPLOTPEN_ACTIVE,wxGenericPen(AveDataColour,line_width));

      draw_pane->AddCurve (curve_data);

        // Draw the Emax line 
      emax_mark.CreateVertLineMarker(lEmax,wxGenericPen(wxGenericColour(_("LIME GREEN"))));
 	  draw_pane->ClearMarkers();
	  draw_pane->AddMarker(emax_mark);
      }
      if (Mode== 1)
	  {
        emax_mark.CreateVertLineMarker(lEmax,wxGenericPen(wxGenericColour(_("LIME GREEN"))));
	    draw_pane->ClearMarkers();
	    draw_pane->AddMarker(emax_mark);
	  }

  loEmax= lEmax;
  draw_pane->CalcBoundingPlotRect();   //as per instructions
  return (TRUE);
}


bool TInspect::drawXAFS (int Mode)
{
  WData * CData;
  int C;
  double E, D, Kmin, Kmax;
  double * CD,*WD;   //passed to wxPlotData
  bool OK= ((lObj->Emax() > lE0) && (lEmax > lE0));
  // Don't change plot bounds for new curves
  draw_pane -> SetFitPlotOnNewCurve(FALSE);
  if (OK)
  {
    if (draw_pane->GetCurveCount()>0 )
	    draw_pane->DeleteCurve(-1);     //remove old curve

      if (lObj->Emin() > lE0)

        Kmin= 0.5123143 * sqrt (lObj->Emin() - lE0);

      else

        Kmin= 0;

      Kmax= 0.5123143 * sqrt (lObj->Emax() - lE0);

      if (Mode== 0)
      {

        /*  // Draw the scale

        Xmin= Kmin;
        Xmax= Kmax;

        Ymax=  lWmax;
        Ymin= -lWmax;

        Border (0.05, 0.1, 0);

        DrawXScale (Kmin, Kmax, 1.00, 0.0);
*/
          // Draw the data 

        CData= Data (lObj, lChannel);

        if (CData== NULL)

          OK= FALSE;

        else

          if ((CData->KScale== NULL) || (CData->Signal== NULL))

            OK= FALSE;

          else
          {
            WD= (double *) calloc (CData->Signal->Nrows(),sizeof(double));
            CD = (double *) calloc (CData->Signal->Nrows(),sizeof(double));
            for (C= 0; C< CData->Signal->Nrows();C++)
			{
                CD[C] = (*(CData->KScale))(C+1);
				WD[C]= (*(CData->Signal))(C+1) * CData->Scale
                              * pow (CD[C], lOrder);
			}
			/* When creating a curve, we pass ownership to wxPlotData, which will
			thus free() the data pointers when it leaves.  So we copy
            our data to separate arrays	*/
            curve_data = wxPlotData(CD,WD,CData->Signal->Nrows());
	    curve_data.SetPen(wxPLOTPEN_NORMAL,wxGenericPen(lDataColour,line_width));
			
            draw_pane->AddCurve (curve_data);
          }

          //Draw the average

        if ((lCoData->KScale== NULL) || (lCoData->Signal== NULL))

          OK= FALSE;

        else
        {
		  CD = (double *) calloc (lCoData->Signal->Nrows(),sizeof(double));
          WD = (double *) calloc (lCoData->Signal->Nrows(),sizeof(double));

          for (C= 0; C < lCoData->Signal->Nrows();C++)
		  {
			CD[C] = (*(lCoData->KScale))(C+1);
            WD[C]= (*(lCoData->Signal))(C+1)
                            * pow (CD[C], lOrder);
		  }
      curve_data = wxPlotData(CD,WD,lCoData->Signal->Nrows());
      curve_data.SetPen(wxPLOTPEN_NORMAL,wxGenericPen(AveDataColour,line_width));

      curve_data.SetPen(wxPLOTPEN_ACTIVE,wxGenericPen(AveDataColour,line_width));
        // Set the viewing region to be fixed relative to the average curve

      if(unzoom)
      {
      wxRect2DDouble rect_edge = curve_data.GetBoundingRect();   //bounds for average curve
      double biggest_bound;
      if (fabs(rect_edge.GetTop())>fabs(rect_edge.GetBottom())) biggest_bound = fabs(rect_edge.GetTop()); 
      else biggest_bound = fabs(rect_edge.GetBottom());
      std::cout << "Bounds are " << rect_edge.GetTop() << " , " << rect_edge.GetBottom() << " , Max " << biggest_bound << std::endl;
      // The top is negative because that's what wxPlotCtrl gives us...
      rect_edge.SetTop(-1.0*biggest_bound*1.5);
      rect_edge.SetBottom(biggest_bound*1.5);
      std::cout << "New rect is " << rect_edge.GetTop() << " , " << rect_edge.GetBottom() << std::endl;
      draw_pane->SetViewRect(rect_edge);
      unzoom = FALSE;
      }
      draw_pane->AddCurve (curve_data);

        // Draw the Emax line 
      }
      if (Mode== 1)
	     {
              Kmax= 0.5123143 * sqrt (lEmax - lE0);
              emax_mark.CreateVertLineMarker(Kmax,wxGenericPen(
			                 wxGenericColour(_("LIME GREEN"))));
		 draw_pane->ClearMarkers();
	     draw_pane->AddMarker(emax_mark);
         }
	  draw_pane->CalcBoundingPlotRect();   //as per instructions
      }
      loEmax= lEmax;
    }
  return (OK);
}

void TInspect::DrawPaint (wxPaintEvent &event)
{
  if(lObj) {           //Mac OSX sends an event even before we can
                       //initialise lObj
  wxPaintDC dc(this);  //Required by MSW, but not used here
  ReDraw();
  }
}

void TInspect::ReDraw ()
{

  WData * cData= Data (lObj, lChannel);

  bool OK= (cData != NULL);

  if (OK)
  {
    showWeight();

    checkbox_use->SetValue(cData->Use != 0);

    if ((cData->Pending== 0) && (lCoData->Pending== 0))

      if (checkbox_xas->IsChecked())

        OK= drawXAS (0);

      else

          // Draw the average curve and the current curve

        OK= drawXAFS (0);
  }

  if (!OK)

    if (lCal== NULL)

      Calculate (1);
}


void TInspect::XASClick (wxCommandEvent &event)
{
  // zoom_spin_button->Enable(!checkbox_xas->IsChecked());
  // weight_spin_button->Enable(!checkbox_xas->IsChecked());
  
  unzoom = TRUE;
  ReDraw();
}

void TInspect::UnzoomClick (wxCommandEvent &event)
{
  unzoom = TRUE;
  ReDraw();
}

void TInspect::FormResize (wxCommandEvent &event)
{
  // WeightPanel.Left= Width - 39;
}

void TInspect::WeightClick(wxSpinEvent &event)
{
   lOrder= weight_spin_button->GetValue();
   Inspect_statusbar->SetStatusText(wxString::Format (_("k^%.0f"), lOrder),2);
   ReDraw(); 
   if (lEmax != 0)       // we have a file loaded
       Calculate(1);
   event.Skip();         // someone else might want it?
}


void TInspect::WeightDownClick (wxSpinEvent &event)
{
  lOrder= lOrder - 1;

  if (lOrder < 0)

    lOrder= 0;

  else
  {
    Inspect_statusbar->SetStatusText(wxString::Format (_("k^%.0f"), lOrder),2);

    ReDraw();
  }

  Calculate (1);
}


void TInspect::WeightUpClick (wxSpinEvent &event)
{
  lOrder= lOrder + 1;

  Inspect_statusbar->SetStatusText(wxString::Format (_("k^%.0f"), lOrder),2);

  ReDraw();

  Calculate (1);
}


void TInspect::CalDone (WData *D)
{
  if ((Data (lObj, lChannel)== D) || (lCoData== D))

	ReDraw();
}


//void Tinspect.CalEnd (wxCommandEvent &event);
void TInspect::CalEnd()
{
	WData * CData;
	TFile * CObj;
	int C;

    // Normalise and Update

  if (!lCal->Interrupted() && (lCal->Entries() > 0))
  {
    lWabs   = 0;
    lWscaled= 0;

    for (C= 0; C< lCal->Entries();C++)
    {
      CData= lCal->Data (C);

      lWabs   = lWabs    + CData->CalWeight;
      lWscaled= lWscaled + CData->CalWeight / CData->Scale;
    }

    lWabs   = lWabs    / lCal->Entries();
    lWscaled= lWscaled / lCal->Entries();

    for (C= 0; C < lCal->Entries();C++)
    {
      CData= lCal->Data (C);

      CObj= (TFile *) (CData->PFile);

      CObj->ChannelW (CData->UF != 0, CData->Channel, CData->CalWeight / lWabs);
    }

    lWscaled= lWscaled / lWabs;
    lWabs   = 1;
  }

  showWeight();

  lCal= NULL;

  ok_button->Enable();

  if (lCalPending > 0)

    Calculate (lCalPending - 1);
}


void TInspect::Calculate (int Mo)
{
  TFile * UObj, *DObj;
  int UChannel, DChannel;
  WData * UData, *DData;
  if (lCal != NULL)
  {

      // Mark the calculation as pending

    if ((Mo < lCalPending) || (lCalPending== 0))

      lCalPending= Mo + 1;

      // Interrupt the thread

    if (Mo <= lCal->getMode())

      lCal->Int();
  }
  else
  {

    lCalPending= 0;

      // Create a new thread
	lCal = new TWeightNoThread(lCoData,Inspect_statusbar,this);

    ok_button->Enable(FALSE);

    lCal->setOnDone(&TInspect::CalDone);

        // Set the mode 

      lCal->setMode(Mo);


        // Add all the data.
	  /* We have potentially multiple channels in multiple files.
	  So the Dobj/Uobj values keep track of the current file
	  object, while lChannel and uchannel keep track of the 
	  current channel.
	  */

      DObj= lObj;      // Start at current file+channel
      DChannel= lChannel;

      /* NextData will actually increment DObj/DChannel,
	  so bear that in mind here.  For reasons to do with
      threads (I think) we load downwards and upwards until we
      meet ourselves coming the other way	  */
      if (NextData (&DObj, DChannel, 1) != NULL)
      {
        UObj    = NULL;
	/* UObj is set to NULL to force the first data point to
		  be written */
        UChannel= lChannel;  //Remember start channel

        do {
          DData= NextData (&DObj, DChannel, -1); //down one

          if ((DObj != UObj) || (DChannel != UChannel)) //looped?
          {
            if (DData->Use != 0)

              lCal->Include (DData, Mo);

            if (UObj== NULL)  //First time through

              UObj= lObj;     //Set our start position

            UData= NextData (&UObj, UChannel, 1); //up one

            if ((DObj != UObj) || (DChannel != UChannel))

              if (UData->Use != 0)

                lCal->Include (UData, Mo);
          }
	  }
        while ((DObj!= UObj) || (DChannel!= UChannel));
      }

      if (lCal->Entries() > 0)

        lCal->lCoData->Pending= 1;

      lCal->lCoData->Scheme= lWScheme;

      lCal->lCoData->E0    = lE0;
      lCal->lCoData->Order = lOrder;
      lCal->lCoData->Emax  = lEmax;

      lCal->Execute();
      CalEnd();
  }
}


void TInspect::UseClick (wxCommandEvent &event)
{
  if (lObj->ChannelUse (lUF, lChannel, checkbox_use->IsChecked()))

    Calculate (1);
}


void TInspect::setlEmax (double E)
{
  if (lEmax != E)
  {
    lEmax= E;

    Calculate (0);
  }
}


void TInspect::setChannel (int C)
{
  if (loChannel != C)

    lcChannel= TRUE;  //Changed channel

  lChannel= C;        //current channel
  loChannel= C;       //original channel
}


void TInspect::setlE0 (double E)
{
  TFile * CFile;
  if ((lE0 != E) && (E != 0))
  {
    lE0= E;

    CFile= lObj->First();

    while (CFile != NULL)
    {
      CFile->setlE0(lE0);
      CFile= CFile->Next();
    }

    Calculate (0);
  }
}


void TInspect::RecalculateClick (wxCommandEvent &event)
{
  if (lCal== NULL)

    Calculate (0);
}


void TInspect::WSchemeClick (wxCommandEvent &event)
{

  int oWScheme= lWScheme;
  int Sender = event.GetId();

  if (Sender== menu_wt_uniform)
  {
    Inspect_statusbar->SetStatusText(_("Uniform"),3);

    lWScheme= 1;
  }

  if (Sender== menu_wt_deviation)
  {
    Inspect_statusbar->SetStatusText(_("Mismatch"),3);

    lWScheme= 2;
  }

  if (Sender== menu_wt_counts)
  {
    Inspect_statusbar->SetStatusText(_("Counting"),3);

    lWScheme= 3;
  }

  if (Sender== menu_wt_noise)
  {
    Inspect_statusbar->SetStatusText(_("Noise"),3);

    lWScheme= 4;
  }

  if (Sender== menu_wt_constnoise)
  {
    Inspect_statusbar->SetStatusText(_("Noise= C"),3);

    lWScheme= 5;
  }

  if (oWScheme != lWScheme)

    Calculate (1);
}


void TInspect::getE0()
{
  TConstants * const_dialog;
  const_dialog = new TConstants((wxWindow *) NULL,-1);
  const_dialog->E0= lE0;

  const_dialog->Emin= 0;
  const_dialog->Emax= 1E6;

  if (const_dialog->ShowModal() == wxID_OK)

    setlE0(const_dialog->E0);
  const_dialog->Destroy();
}

void TInspect::setUF(bool nUF)
{
	lUF = nUF;
}

void TInspect::setObj(TFile * nObj)
{
	lObj = nObj;
}

void TInspect::ChangeE0Click (wxCommandEvent &event)
{
  getE0();
}


void TInspect::OKClick (wxCommandEvent &event)
{
  Close();
}

/* void TInspect.BackgroundClick (Sender: TObject)
{
  if (Color== clBlack)
  {
    Color= clNavy;

    Background.Caption= 'Black background';
  }
  else
  {
    Color= clBlack;

    Background.Caption= 'Blue background';
  }
}

void TInspect::DataColorClick (wxCommandEvent &event)
{
  if (lDataColor== clBlue)
  {
    lDataColor= clRed;

    DataColor.Caption= 'Blue data';
  }
  else
  {
    lDataColor= clBlue;

    DataColor.Caption= 'Red data';
  }

  draw_pane->Refresh();
}
*/
